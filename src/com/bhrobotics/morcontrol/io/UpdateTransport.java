/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.bhrobotics.morcontrol.io;

import java.util.Hashtable;
import java.util.Vector;
import java.util.Enumeration;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.transport.*;
import org.apache.thrift.protocol.*;

public class UpdateTransport {

	public interface Iface {

		public Event waitForUpdate() throws TException;

	}

	public static class Client implements TServiceClient, Iface {
		public Client(TProtocol prot) {
			this(prot, prot);
		}

		public Client(TProtocol iprot, TProtocol oprot) {
			iprot_ = iprot;
			oprot_ = oprot;
		}

		protected TProtocol iprot_;
		protected TProtocol oprot_;

		protected int seqid_;

		public TProtocol getInputProtocol() {
			return this.iprot_;
		}

		public TProtocol getOutputProtocol() {
			return this.oprot_;
		}

		public Event waitForUpdate() throws TException {
			send_waitForUpdate();
			return recv_waitForUpdate();
		}

		public void send_waitForUpdate() throws TException {
			oprot_.writeMessageBegin(new TMessage("waitForUpdate", TMessageType.CALL, ++seqid_));
			waitForUpdate_args args = new waitForUpdate_args();
			args.write(oprot_);
			oprot_.writeMessageEnd();
			oprot_.getTransport().flush();
		}

		public Event recv_waitForUpdate() throws TException {
			TMessage msg = iprot_.readMessageBegin();
			if (msg.type == TMessageType.EXCEPTION) {
				TApplicationException x = TApplicationException.read(iprot_);
				iprot_.readMessageEnd();
				throw x;
			}
			if (msg.seqid != seqid_) {
				throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "waitForUpdate failed: out of sequence response");
			}
			waitForUpdate_result result = new waitForUpdate_result();
			result.read(iprot_);
			iprot_.readMessageEnd();
			if (result.isSetSuccess()) {
				return result.success;
			}
			throw new TApplicationException(TApplicationException.MISSING_RESULT, "waitForUpdate failed: unknown result");
		}

	}

	public static class Processor implements TProcessor {
		public Processor(Iface iface) {
			iface_ = iface;
			processMap_.put("waitForUpdate", new waitForUpdate());
		}

		protected static interface ProcessFunction {
			public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
		}

		private Iface iface_;
		protected final Hashtable processMap_ = new Hashtable();

		public boolean process(TProtocol iprot, TProtocol oprot) throws TException {
			TMessage msg = iprot.readMessageBegin();
			ProcessFunction fn = (ProcessFunction) processMap_.get(msg.name);
			if (fn == null) {
				TProtocolUtil.skip(iprot, TType.STRUCT);
				iprot.readMessageEnd();
				TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '" + msg.name + "'");
				oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
				x.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
				return true;
			}
			fn.process(msg.seqid, iprot, oprot);
			return true;
		}

		private class waitForUpdate implements ProcessFunction {
			public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
				waitForUpdate_args args = new waitForUpdate_args();
				try {
					args.read(iprot);
				} catch (TProtocolException e) {
					iprot.readMessageEnd();
					TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
					oprot.writeMessageBegin(new TMessage("waitForUpdate", TMessageType.EXCEPTION, seqid));
					x.write(oprot);
					oprot.writeMessageEnd();
					oprot.getTransport().flush();
					return;
				}
				iprot.readMessageEnd();
				waitForUpdate_result result = new waitForUpdate_result();
				result.success = iface_.waitForUpdate();
				oprot.writeMessageBegin(new TMessage("waitForUpdate", TMessageType.REPLY, seqid));
				result.write(oprot);
				oprot.writeMessageEnd();
				oprot.getTransport().flush();
			}

		}

	}

	public static class waitForUpdate_args implements TBase {
		private static final TStruct STRUCT_DESC = new TStruct("waitForUpdate_args");

		public waitForUpdate_args() {
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public waitForUpdate_args(waitForUpdate_args other) {
		}

		public waitForUpdate_args deepCopy() {
			return new waitForUpdate_args(this);
		}

		public void clear() {
		}

		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof waitForUpdate_args)
				return this.equals((waitForUpdate_args) that);
			return false;
		}

		public boolean equals(waitForUpdate_args that) {
			if (that == null)
				return false;

			return true;
		}

		public int hashCode() {
			return 0;
		}

		public int compareTo(Object otherObject) {
			if (!getClass().equals(otherObject.getClass())) {
				return getClass().getName().compareTo(otherObject.getClass().getName());
			}

			waitForUpdate_args other = (waitForUpdate_args) otherObject;
			int lastComparison = 0;

			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				default:
					TProtocolUtil.skip(iprot, field.type);
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			validate();

			oprot.writeStructBegin(STRUCT_DESC);
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		public String toString() {
			StringBuffer sb = new StringBuffer("waitForUpdate_args(");
			boolean first = true;

			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
		}

	}

	public static class waitForUpdate_result implements TBase {
		private static final TStruct STRUCT_DESC = new TStruct("waitForUpdate_result");

		private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short) 0);

		private Event success;

		// isset id assignments

		public waitForUpdate_result() {
		}

		public waitForUpdate_result(Event success) {
			this();
			this.success = success;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public waitForUpdate_result(waitForUpdate_result other) {
			if (other.isSetSuccess()) {
				this.success = new Event(other.success);
			}
		}

		public waitForUpdate_result deepCopy() {
			return new waitForUpdate_result(this);
		}

		public void clear() {
			this.success = null;
		}

		public Event getSuccess() {
			return this.success;
		}

		public void setSuccess(Event success) {
			this.success = success;
		}

		public void unsetSuccess() {
			this.success = null;
		}

		/**
		 * Returns true if field success is set (has been assigned a value) and
		 * false otherwise
		 */
		public boolean isSetSuccess() {
			return this.success != null;
		}

		public void setSuccessIsSet(boolean value) {
			if (!value) {
				this.success = null;
			}
		}

		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof waitForUpdate_result)
				return this.equals((waitForUpdate_result) that);
			return false;
		}

		public boolean equals(waitForUpdate_result that) {
			if (that == null)
				return false;

			boolean this_present_success = true && this.isSetSuccess();
			boolean that_present_success = true && that.isSetSuccess();
			if (this_present_success || that_present_success) {
				if (!(this_present_success && that_present_success))
					return false;
				if (!this.success.equals(that.success))
					return false;
			}

			return true;
		}

		public int hashCode() {
			return 0;
		}

		public int compareTo(Object otherObject) {
			if (!getClass().equals(otherObject.getClass())) {
				return getClass().getName().compareTo(otherObject.getClass().getName());
			}

			waitForUpdate_result other = (waitForUpdate_result) otherObject;
			int lastComparison = 0;

			lastComparison = TBaseHelper.compareTo(isSetSuccess(), other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = this.success.compareTo(other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public void read(TProtocol iprot) throws TException {
			TField field;
			iprot.readStructBegin();
			while (true) {
				field = iprot.readFieldBegin();
				if (field.type == TType.STOP) {
					break;
				}
				switch (field.id) {
				case 0: // SUCCESS
					if (field.type == TType.STRUCT) {
						this.success = new Event();
						this.success.read(iprot);
					} else {
						TProtocolUtil.skip(iprot, field.type);
					}
					break;
				default:
					TProtocolUtil.skip(iprot, field.type);
				}
				iprot.readFieldEnd();
			}
			iprot.readStructEnd();
			validate();
		}

		public void write(TProtocol oprot) throws TException {
			oprot.writeStructBegin(STRUCT_DESC);

			if (this.isSetSuccess()) {
				oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
				this.success.write(oprot);
				oprot.writeFieldEnd();
			}
			oprot.writeFieldStop();
			oprot.writeStructEnd();
		}

		public String toString() {
			StringBuffer sb = new StringBuffer("waitForUpdate_result(");
			boolean first = true;

			sb.append("success:");
			if (this.success == null) {
				sb.append("null");
			} else {
				sb.append(this.success);
			}
			first = false;
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws TException {
			// check for required fields
		}

	}

}
